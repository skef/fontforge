<HTML>
<HEAD>
<!-- Created with AOLpress/2.0 -->
<!-- AP: Created on: 6-Dec-2000 -->
<TITLE>FontForge -- An Open Source Font Editor</TITLE>
<LINK REL="icon" href="fftype16.png">
<LINK REL="stylesheet" TYPE="text/css" HREF="FontForge.css">
</HEAD>
<BODY>
<DIV class="subhead">An Open Source Font Editor</DIV>
<DIV class="splash"><IMG SRC="FontForgeSplash.png" WIDTH="379" HEIGHT="375" ALT="Gaudiamus ligature!"></DIV>
<DIV class="quote">
Eeyore had <A NAME="three-sticks">three</A> sticks on the ground,
and was looking at them. Two of the sticks were touching at one end, but
not at the other, and the third stick was laid across them. Piglet thought
that perhaps it was a Trap of some kind.
<P>
“Oh, Eeyore,” he began again, “just —”
“Is that little Piglet?” said Eeyore, still looking hard
at his sticks.
<P>
“Yes, Eeyore, and I—”
<P>
“Do you know what this is?”
<P>
“No,” said Piglet.
<P>
“It's an A.”
<P>
“Oh,” said Piglet.
<P>
“Not O, A,” said Eeyore severely.
<DIV class="attribution">
— A. A. Milne, 1928<BR>
The House At Pooh Corner
</DIV>
</DIV>

<DIV class="quote">
Font design can be a Trap, but I find it a rather pleasant one. <EM>Caveat utor</EM>.
</DIV>

<H2 id="Overview">Overview</H2>

FontForge is a font editor — a program designed to create and modify fonts.  It
can open existing Postscript, TrueType and OpenType fonts, save many different
outline formats, and generate bitmaps.

<P> Like the drawing programs FreeHand, Inkscape and Illustrator, it lets you
draw the outlines of letters. But unlike those programs it is designed to 
organize the pictures you draw <EM>by</EM> letter in a kind of database.

<P> It also allows you to describe the way these “pictures” interact with each other
when translated into a font format. For example, if you put the picture for “n” after
the picture for “o”, you can specify how much space should separate them. That distance
is one of a fonts “metrics”. Or you might specify that when an “i” follows an ”f”, a
different picture depicting the combination should be shown instead. This would be a
”ligature” — one of the ”features” of a font. And so on. 

<P> The role of a font editor is to keep track of all of this information and 
eventually to translate it into a ”font” — a file that a computer can use to
display and print text. 

<H3 id="intro">Introductory concepts: Fonts, Splines, Lines, Points, Paths and the em-unit</H3>

<P>At its simplest a font is a collection of <EM>glyphs</EM> — pictures of
letters, numbers, accents, puncutation, and so on. However, computer fonts
generally contain many other kinds of information. At the least each must
specify which abstract “characters” correspond to which glyphs.  This mapping
is called an “encoding”.  Many fonts also contain rules for how adjacent glyphs
should be arranged. For instance, in fonts for the latin alphabet, there is
often a rule saying that if an "f" is followed by an "i" then a special glyph,
a ligature of "f" and "i" should be used instead. Fonts for latin letters
generally do not require such rules (but can be enhanced by them), fonts for
other scripts like arabic require them.

<H4>What is the difference between a character and a glyph?</H4>

<P> In effect, a character is a concept and a glyph is a reification of that
concept. The letter "A" is a character <IMG SRC="As.png"> are all glyphs that
represent an "A". In many latin fonts there is one glyph for every character
supported, but this not always true.  In renaissance printing there were two
glyphs for a lower-case s, <IMG SRC="short-long-s.png">the short and the long
s. A ligature is a glyph that represents two or more characters. In arabic
fonts most of the letters (characters) have at least four different glyphs,
with the appropriate glyph being determined by not a single character but a
group of characters in sequence.  Here are four forms of the arabic character
"seen":

<P><IMG SRC="arabic-seen.png" WIDTH="108" HEIGHT="17" ALIGN="Middle">.

<H4>What is an outline font? What is a bitmap font?</H4>

<P> In a traditional font the ”picture” that constitutes a glyph is just a
<EM>shape</EM> — a set of straight or curved lines that specify where ink (or
its equivalent) should touch paper (or its). Different font formats have
different means of specifying shapes, but there are two basic categories:
<EM>outlines</EM> and <EM>bitmaps</EM>.  PostScript and TrueType fonts
generally specify a set of <EM>contours</EM> — lines that start and end in the same
place and are therefore ”closed”. Each contour is encoded to indicate whether
it encloses an area to be included — where ink would be put — or excluded — as
with the center of an “o”.  A bitmap font, in contrast, specifies each glyph
with a set of bits, which are treated as if arranged in a rectangular grid.  In
this system a 1 could indicate where ink should be placed and a zero where
should be left as is.  There is also a third, less common type — a
<EM>stroked</EM> font —  where each "stem” of the glyph is represented by a
line down the center of the stem. This line is then “drawn” with a width
specified by other means in the font. (There is more information about stroked
fonts in the section on <A HREF="multilayer.html">multi-layered editing</A>.)

<TABLE BORDER CELLPADDING="2">
  <TR VALIGN=Top>
    <TD><P ALIGN=Center>
	<I><IMG WIDTH="117" HEIGHT="201" SRC="outlinechar.png"></I><BR>
	A glyph's outline</TD>
    <TD><P ALIGN=Center>
	<IMG SRC="bitmapchar.png" WIDTH="117" HEIGHT="201"><BR>
	A glyph's bitmap</TD>
    <TD><P ALIGN=Center>
	<IMG SRC="strokechar.png" WIDTH="208" HEIGHT="198"><BR>
	A stroked glyph<BR>
	(showing the equiv. outline in grey)</TD>
  </TR>
</TABLE>

<P> Some more recent font formats can describe glyphs with multiple colors, which 
are therefore not accurately described as just a “shape”. However, these formats
typically extend the older ones, most often an outline format. Instead of just 
specifying where ink should be present or absent, the outlines are assigned to
“layers” where each layer corresponding to a color. The ordering of the layers
determines the overall glyph, with “higher” layers covering lower layers where
the outlines overlap. 

<P> With respect to glyphs, FontForge is primarily an outline editing tool. However,
this does not mean it can't be used to create bitmap fonts. The bitmaps for a glyph
need to be created and edited somehow, and a tool that simply presented a grid and
let the user turn bits on or off would be absurdly cumbersome. FontForge can ”import”
bitmaps created in other tools, but it is also designed to convert outlines into
bitmaps, much like a computer eventually converts an outline font into bitmaps 
to display a character on your screen, or a printer converts one to bitmaps to 
determine where to place ink or toner. Thus outlines created in FontForge can be
used to generate a bitmap font. 

<H4>Bézier splines and contours</H4>

<P> An outline is composed of a set of contours or ”paths”. In the picture on
the above left the letter A is described by three different paths. The main one
is on the outside and the two smaller ones are internal. Each of these paths is
composed of a series of (Bézier) splines and line segments. FontForge can edit
both cubic and quadratic splines. PostScript fonts are specified with cubic
splines and TrueType fonts with quadratic splines. Some other formats,
including OpenType and SVG, can use either.

<P> Each <EM>cubic</EM> <A NAME="spline">spline</A> is defined by four points,
two of which mark the end points of the spline and two more to describe the
slope of the spline at those end points. Here are <A HREF="bezier.html">two
cubic splines</A> with all their points shown:

<P> <IMG SRC="splines.gif" WIDTH="172" HEIGHT="179" ALIGN="Left">

<P> The points which describe the slope are called ”control” or ”off-curve”
points. They are represented here (and in FontForge) by little colored x's.
Moving a control point will change the shape of the spline but it will not
alter where the spline begins or ends.

<P> <IMG SRC="pnts.gif" WIDTH="169" HEIGHT="165" ALIGN="Right">A series of
splines and lines are joined together to make a path. There are several
possible ways to make these joins, depicted in the example to the right. In
each case we have three points in approximately the same relative positions.
The three points are joined by splines or lines, but the type of joins alters
the appearance of the connections.

<P> In the first case there are no control points and the result is two
straight lines, in the second case there is a line and a curved spline which
are tangent at their point of intersection, in the third case there are two
splines which are again tangent at their point of intersection. The point of
intersection in the first case is called a “corner” point. This is the most
general type of point, where the incoming and outgoing splines or lines may
have any orientation with respect to each other. This is represented in
FontForge by a square box. In the second case the point of intersection is
called a ”tangent” point, and is represented by a triangle.  The third case is 
called a ”curve” point and is represented by a circle.

<P> <IMG ID="quadratic" SRC="quadraticspline.gif" WIDTH="127" HEIGHT="92"
ALIGN="Left">FontForge can also edit <EM>quadratic</EM> splines — the splines
used in TrueType fonts).  In a quadratic spline there is at most one control
point between end-points that controls the curvature in each direction.
A quadratic spline cannot bend in as many ways as a cubic splines — the first cubic
spline above left would need to be drawn with at least two quadratic splines —
and therefore more splines are often needed to achieve a given curve. You can control
whether a font contains cubic or quadratic splines with the 
<A HREF="fontinfo.html#PS-General">Element-&gt;Font Info</A> dialog.

<H4>Clothoid splines</H4>

<P> There are many known types of splines. The ones described above are Béziers
— these are numerically simple and have a number of other nice properties —
which is why they are used internally in fonts. However, there are some even
nicer splines. It is easy to give Bézier splines the same slope on either side
of a point, but a curve will look much nicer if it has the same curvature on
either side of a point. Clothoid splines have this property.  <A
HREF="http://www.levien.com/">Raph Levien</A> has kindly donated to the open
source community a <A HREF="http://libspiro.sf.net/">library</A> for converting
clothoid splines into Béziers.

<P> Clothoid splines are much easier to work with than Béziers. There are no
control points, just a sequence of on-curve points, between which a beautiful
curve will magically appear. FontForge can edit a curve 
<A HREF="charview.html#spiro-mode">either</A> as a set of Béziers or as a
set of clothoids.

<H4>Combining contours</H4>

<P> A path is <EM>closed</EM> when it comes back and joins its start. All paths
in an outline font should be closed. Once a path is closed (and does intersect
itself) it has a <EM>direction</EM>: either <EM>clockwise</EM> or
<EM>counter-clockwise</EM>.  (A path that intersects itself, as in a figure 8,
cannot be described as clockwise or counter-clockwise.  However, while it is
possible to create such a path in FontForge, it is never desirable to.  Paths
in an outline font <STRONG>should not</STRONG> self-intersect.) 

<P> In FontForge the direction of a spline determines whether it surrounds a
“dark” or “inked” area or an area to be left clear of ink.  Look at the outline
of A above, which has two contours inside a third. The interior of the two
inner contours should be free of ink, while the area from their exteriors up to
the outer contour should be inked. FontForge fills that area in because the
outer contour has a clockwise direction while the inner contours are
counter-clockwise.

<P> Not every shape is as simple as these. A general rule for which areas will be
inked, or “part of the shape”, and which will not, can be difficult to
understand or apply. However, this guideline covers most cases: To <EM>add</EM>
an “inked” or “filled-in” area to the glyph, put a <EM>clockwise</EM> contour
around it. To <EM>remove</EM> ink or fill from an area inside a clockwise
contour, put a <EM>counter-clockwise</EM> contour around it. Then repeat this
pattern in any additional area to be filled in, whether no contour surrounds it
or a counter-clockwise contour surrounds it. Putting a clockwise contour
directly inside another clockwise contour, or a counter-clockwise contour
directly inside another counter-clockwise contour, will generally have no good
effect and could confuse some tools; they should always alternate. And the
“outer” contour of any part of a glyph should always be clockwise.

<P> While a given contour should never intersect itself, there are some cases
where it can make sense for the areas traced by different contours to
<EM>overlap</EM>. Some font formats do not support overlapping contours, but
FontForge <A HREF="XXX">can be configured to remove the overlap</A> when
generating fonts of those types.

<H4>Scale</H4>

<P> In the examples so far we have discussed <EM>points</EM> by way of
illustrative pictures and not their mathematical representation.  Although
FontForge is graphical tool, some understanding of that representation is
needed to build a well-formed font. 

<P> Each point is positioned on a cartesian coordinate system which has its
origin on the glyph's <A HREF="#Baseline">baseline</A> (the line on which
letters without descenders rest). Most font formats expect coordinates to be
integers between -32768 and 32767, FontForge uses “floating point” numbers
internally but (usually) rounds to the nearest integer when generating a font
file, and it is generally a good idea to restrict yourself to integral
coordinates.  

<P> An "<A NAME="em-unit"><EM>em</EM></A>" is a length measure that corresponds
to the chosen size of a font.  The size of fonts is typically discussed in
terms of “points”, but here that word does not refer to a point on a plane but
a unit of length that is (usually) 1/72nd of an inch. For example, if a given
font is displayed at the quite common size of 12 points, or 1/6th of an inch,
then 1 em is 12 points in length. And if the font is displayed at 18 points
then an em will be 18 points in length.

<P> A typical outline font can be scaled to any point size. Although many
fonts are designed to look best within a certain range of sizes, as you
design a new font you don't know and should't focus on the exact size at
which it may be used. It is therefore best to use ems, rather than points, as
the basic measure.  When you create a font in FontForge you choose how many
internal units, called "em-units" or just “units”, to use to represent 1 em —
this number is called the "em-size". 

<P> The choice of em-size is at most loosely related to the size at which a
font may eventually be displayed or printed. It is primarily about how many
integer coordinates are needed. A font with an em-size of 20 would only have
(about) 20 separate heights for an integer point coordinate, which could lead
to some points looking “misplaced”. Most PostScript fonts have 1000 units to
the em, while TrueType fonts often have either 1024 or 2048 units (TrueType
recommends that you use a power of two). However you can choose any positive
number less than 32767, as these numbers are conventions rather than
requirements. A high number gives your coordinates more “precision”, which
may benefit a particularly detailed font intended to be displayed at large
point <izes.

<P> Suppose you add a dash that is 500 units long to a font with 1000 units to
the em.  When someone chooses to use that font at 12 points, the dash will be
drawn with a length of 500/1000 * 12 = 6 points or (usually around) 1/12th of an
inch.

<H4>Coordinates and spacing</H4>

<P> <IMG SRC="sidebearings.png" WIDTH="111" HEIGHT="191" ALIGN="Right">Every
glyph has its own two-dimensional coőrdinate system. The font's <A
HREF="#Baseline">baseline</A>
(the line upon which most latin glyphs will rest) is 0 in the vertical or ^y“
direction. Zero on the horizontal or “x” axis is where the glyph is considered
to start, although lowest x coordinate of any contour is typically greater than
zero to leave some space between it and a previously displayed glyph.  This
horizontal distance between the origin and the leftmost edge of the glyph is
called the “left side bearing”. It may be positive, zero, or even negative, and
therefore points can have negative coordinates.  All glyphs have a width,
sometimes alled the “advance width”, which is the distance from the origin of
the current glyph to the origin of the next. The distance between the right
edge of the glyph (the highest x value in any contour) and the width is called
the “right side bearing”.

<P> CJK text (Chinese, Japanese or Korean) can be written either vertically or
horizontally, and accordingly CJK fonts usually have a “vertical advance width”
as well as the more common horizontal advance with (and concomittant top and
bottom side bearings).

<P> Most latin (and greek and cyrillic) fonts have certain standard heights:
the height of most lower case letter s is called the “x-height”, the height of
a capital letter is called the “cap-height”.  A glyph like "k" or "l" extends
above the x-height, a portion called an “ascender” that typically rises to a
common “ascender line” or “ascent”, which may or may not be the same as the
cap-height.  A glyph like "g" or "y" extends below the baseline; a portion
called a descender that typically lowers to a common “descender line” or
^descent”. While these various heights are established across the whole font,
not all glyphs will have exactly those heights.  The letter "O" is usually
slightly taller than the letter "I", but they both are within the range of the
cap height for the font.

<P> In the days of metal type no glyph could extend above the the ascent or
below the descent. In digital fonts a glyph can do either, but the concept is
still a convenient one to retain; in almost all cases a glyph should not ascend
above or descend below the font-wide ascent and descent.  The sum of the ascent
and descent is the size of the font. 

<H4 id="References">References</H4>

<P> In addition to a set of contours, a glyphs can be built in part or whole
with a <EM>reference</EM> to another glyph. This is especially handy for the
accented glyphs; "à" can be made up of a reference to the "a" glyph and another
reference to the "`" glyph. This can result in significant space savings, but
more importantly it can ease the design process.  Even if you change the "a"
glyph after making a reference to it, the "à" glyph will automatically change
too, whereas if you just copied the "a" you would have to recopy it.

<P>
FontForge has three commands for manipulating references and one higher
level command for building accented glyphs. The
<CODE><A HREF="editmenu.html#Reference">Edit-&gt;Copy Reference</A></CODE>
command will put a reference to the current glyph into the clipboard.
A subsequent
<CODE><A HREF="editmenu.html#Paste">Edit-&gt;Paste</A></CODE> command will
add the reference to the current glyph. And the
<CODE><A HREF="editmenu.html#Unlink">Edit-&gt;Unlink Reference</A>
</CODE>command will convert a reference into it's component splines.
The <CODE><A HREF="elementmenu.html#Info">Element-&gt;Get Info</A>
</CODE>command, when applied to a reference, will bring up a dialog showing
you what glyph is referred to, and allow you to open an editing window
for that glyph. Finally the
<CODE><A HREF="elementmenu.html#Accented">Element-&gt;Build-&gt;Accented
Glyphs</A></CODE> command will figure out what glyphs should be refered to
to build this composite glyph and then add and position those references
appropriately. So if "à" were selected and you ran the
<A HREF="elementmenu.html#Accented"><CODE>Element-&gt;Build-&gt;Accented
Glyphs</CODE></A> command, FontForge would make a reference to "a" and another
to "`", and center the accent above the letter.

<P> At least one bitmap font formats also supports references, so FontForge
allows references in bitmap glyphs as well as in outline glyphs.

<P> Depending on the format chosen, the references FontForge uses internally
cannot always be preserved in a generated font.  Generally this causes no
problems as FontForge will simply unlink the references at generation time.
Usually this just leaves the font a little bigger, but it can have implications
for instructing TrueType, and, to a lesser extent, hinting PostScript (see XXX
below). Most people can ignore this, but if you are interested there is more
information <A HREF="ref-caveats.html">here</A>.

<P> Most font formats require that a glyph contain either a set of contours (or
bitmap rasters) or a set of references, but not both. FontForge allows glyphs
to be built from any combination of references and contours, but when it comes
time to output the results FontForge will “clean up” the glyph, generally by
unlinking references, so that it can be output in the chosen format.

<H3 id="Layers">Layers</H3>

<P> A font may have several layers. When FontForge creates a new font it will
start with 2 layers for each glyph — the <EM>foreground</EM> and
<EM>background</EM> layers — as well as a <EM>guideline</EM> layer shared by all
glyphs. In most font formats all glyphs have the same number of layers (This is
not true of <A HREF="#Type3">Type3 fonts</A>.)

<P> Both the foreground layer and the background layer have certain predefined
meanings: The foreground is the default layer, and is altered by commands and
dialogs for which there is no way to specify a layer. The background layer can
contain whatever splines or raster images you want wish, but is usually used
for “reference” material, including images that can be autotraced into the
foreground layer.

<P> You may add other layers with the
<CODE><A HREF="fontinfo.html#Layers">Element-&gt;Font Info-&gt;Layers
</A></CODE>pane. Each layer may have a name and a different kind of spline
(quadratic or cubic).

<P> One potential use of addtional layers: Many people find it easier to edit
using cubic splines but like to produce truetype fonts with quadratic splines.
You can use one layer to hold the cubic splines and another to hold the
quadratics. There is a command for comparing layers — <CODE><A
HREF="elementmenu.html#CompareL2L">Element-&gt;Compare Layer To
Layer</A></CODE> — and one to copy one layer to another, adjusting the splines
to fit the new layer — <CODE><A HREF="editmenu.html#CopyL2L">Edit-&gt;Copy
Layer To Layer</A></CODE>.

<P> It would be a shame to have both a valid cubic and a valid quadratic font in
a FontForge database and only be able to produce a font from one of them. Accordingly
the font view allow you to switch between layers using
<CODE><A HREF="viewmenu.html#FVLayers">View-&gt;Layers-&gt;*</A></CODE>.
The <CODE><A HREF="generate.html">File-&gt;Generate Fonts</A></CODE> command
then allows you to output the layer of your choice into the font. (Note that
all layers will share all other information, including hints, instructions, character set, bitmaps,
and so forth. It is only the outlines which differ.) Furthermore, you may choose to
store all the layers of a font into an “sfnt” (TrueType / OpenType font) with
the <A HREF="generate.html#Options"><CODE>[]Layers</CODE> checkbox of the
PfaEdit table of the <CODE>[Options]</CODE></A><CODE> </CODE>dialog.

<H2>The Main Windows</H2>
<H3 id="FontView">Font View</H3>

<P> <IMG SRC="AmbrosiaFV.png" WIDTH="423" HEIGHT="226">

<P> FontForge's <A HREF="fontview.html">Font View</A> window generally displays
all of the glyphs in the font in a scrolling grid, although it can be
configured to display only a subset of fonts. Every element in the grid has two
parts. At the is a smaller depiction of the character taken from another,
configurable font.  Underneath that is an image of glyph as currently recorded
in the database.  As you edit a glyph in an <A HREF="#CharView">Outline Glyph
View</A> this image will change as well. The size of the images is configurable, 
and double-clicking on a glyph will bring up an outline glyph view of that glyph
which will allow you to edit it. You can also select one or more glyphs in order
to copy or paste outlines or references or apply various operations to all of
them at once. 

<P> Fonts do not need to be for the latin alphabet alone. This is a view of
one of <A HREF="ftp://ftp.ipl.t.u-tokyo.ac.jp/Font/">Wadalab</A>'s public
domain Kanji fonts:

<P> <IMG SRC="kanjifont.png" WIDTH="423" HEIGHT="212">

<P> And here is another Wadalab font encapsulated in a CID keyed font:

<P> <IMG SRC="fontview-cid.png" WIDTH="573" HEIGHT="226">

<H3 id="CharView">Outline Glyph View</H3>

<P> <IMG SRC="charview2.png" WIDTH="544" HEIGHT="656">

<P> The <A HREF="charview.html">Outline view</A> is probably the most complex
window in FontForge. This is where you actually edit the splines (<A
HREF="bezier.html">Bézier splines</A>) that make up your glyphs.

<P> If you have a reference image scanned from paper or made with another tool,
you may load it into the background layer to help you trace out its shape (it
is displayed in grey). There are also various grid lines visible, some created
by default that correspond to certain metrics (the baseline, the ascent and
descent lines, and a line at x=0), and you may add others by editing the
guideline layer. 

<P> The splines and points of the glyph itself are in the foreground layer, along
with the width line moving the width line adjusts the right side bearing while 
moving the x=0 line adjusts the left side bearing. By default all points, both 
on-curve and control, are displayed.

<P> The Glyph View window also has two pallettes. By default these are integrated
into its left-hand side, but they can also be placed into separate windows. The
upper pallette has a grid of tools while the lower palette is used to switch between
and alter layers. 

<H3 id="BitmapView">Bitmap View</H3>

<P> <IMG SRC="BitmapView.png" WIDTH="254" HEIGHT="273">

<P> The <A HREF="bitmapview.html">bitmap view</A> is similar to the Outline
View, and has two similar palettes. It allows you to edit bitmap versions of
your outline glyphs.

<P> In the background is a small rendition of the outline, while in the
foreground are the “bits” of the image. You may make the program calculate which
bits should be set by pressing the "Recalculate˘ button. The results usually
need to be tweaked by hand. In the upper left corner is a full-sized image of
your bitmap glyph.

<H3 id="MetricsView">Metrics View</H3>

<TABLE>
  <TR>
    <TD><IMG SRC="MetricsView.png" WIDTH="479" HEIGHT="331"></TD>
    <TD><IMG SRC="MetricsView-features.png" WIDTH="463" HEIGHT="330"></TD>
  </TR>
</TABLE>

<P> The <A HREF="metricsview.html">metrics view</A> allows you to see how the
glyphs look together, and to change the left and right side bearings of a
glyph, either by dragging in the upper part of the window or by entering an
appropriate number in the lower field. You can also provide kerning information
for any two adjacent glyphs, and iew how various OpenType features XXX affect the
glyph stream.

<P> <IMG SRC="VerticalMetrics.png" WIDTH="270" HEIGHT="573" ALIGN="Right">Note
that in Hebrew, or Arabic (or any other right to left alphabet) the glyphs
will start on the right and run to the left. In CJK fonts you may want
to see things arranged vertically.

<P> <IMG SRC="HebrewMetrics.png" WIDTH="511" HEIGHT="323">

<H3>Types of Font</H3>

Most of the information about glyphs and metrics presented so far applies to
almost any variety of digital font. The rest of this introduction is about
aspects of fonts that are more specific, and to discuss these aspects we 
need to say a bit the two font formats in most most common use at the
present time: TrueType and OpenType. Information about some additional 
common formats is available here XXX>

<P>
FontForge can produce many font types. What's the difference?
<P>
PostScript is based on a <A HREF="bezier.html">cubic spline</A> technology,
while TrueType is based on a <A HREF="bezier.html">quadratic</A> technology.
Cubic splines are generally easier to edit (more shapes are possible with
them). Any quadratic spline can be converted to a cubic spline with essentially
no loss. A cubic spline can be converted to a quadratic with arbitrary precision,
but there will be a slight loss of accuracy in most cases.
<P>
Within FontForge a font may contain either cubic or quadratic splines. These
are converted to the appropriate format when a font is generated.
<P>
The other major difference between the two is how they solve the problem
of drawing nice images at small pointsizes. PostScript calls this "Hinting",
while TrueType calls it "Instructing" a font.
<H4>
  What's OpenType?
</H4>
<P>
Unfortunately the word "OpenType" has come to have several meanings.
<P>
The first meaning describes the glyph (and spline) format of the font. In
this sense Open Type is just a postscript font put into a truetype file format
-- From the outside it looks like a truetype font except that the outline
descriptions are postscript Type2 font descriptions rather than TrueType.
Technically it is a <A HREF="glossary.html#CFF">CFF</A> font inside an
<A HREF="glossary.html#SFNT">sfnt</A> wrapper.
<P>
In a second sense of the word OpenType refers to a set of tables containing
advanced typographic information. These tables may be added to either fonts
specified with quadratic splines (truetype) or fonts with cubic splines.
<P>
Finally MS Windows uses an OpenType icon for a font if that font contains
a 'DSIG' (Digital Signature) table.
<P>
To make things even more confusing the OpenType specification includes the
old TrueType specification, so technically any TrueType font can be called
an OpenType font.
<P>
FontForge does not support the DSIG table (if you want one there is a free
tool from MS which will add one). When generating a font, FontForge uses
the term "OpenType (CFF)" to represent a PostScript (CFF) font inside an
sfont wrapper. To include OpenType typography tables you would press the
<CODE>[Options] </CODE>button and select the <CODE>[] OpenType</CODE> check
box.
<H4>
  What's SVG?
</H4>
<P>
SVG (Scalable Vector Graphics) provides a relatively new font format, written
in an xml dialect. SVG fonts can be either cubic or quadratic (or can use
both, but FontForge is limited and will force a font to be either all cubic
or all quadratic). SVG allows for two different types of fonts, one corresponds
roughly to PostScript Type1 fonts, and the other, roughly to PostScript Type3
fonts.
<H4>
  What are Type3 fonts?
</H4>
<P>
Back in the early days of PostScript, the Type1 format was proprietary, only
Adobe could make Type1 fonts, but anyone could make Type3 fonts. Type3 fonts
were unhinted, but could include any postscript command and so could produce
a wider range of pictures (multi-colored glyphs, stroked glyphs, glyphs based
on scaled images, etc.). Most of the time these extensions are unnecessary,
and the disadvantage of being unhinted is onerous -- but sometimes you want
to play.
<H4>
  What are Type1 fonts?
</H4>
<P>
These were the standard stand-alone PostScript fonts of the '80s and '90s.
<H4>
  What are Type2 fonts?
</H4>
<P>
These use a slightly different internal format (a more compact one) to express
the same information as type1. This is the format that lives inside a CFF
font which lives inside an OpenType font.
<H4>
  What are CFF fonts?
</H4>
<P>
This is the font format that is designed to store PostScript Type2 information.
It is most commonly found inside an OpenType (PostScript) font.
<H4>
  What is Apple Advanced Typography?
</H4>
<P>
This is another way of specifying typographic information (like ligatures,
kerning, glyph substitutions). It appeared before OpenType and is only used
on Apple computers. It is based on state machines and is a little harder
to work with than OpenType.

<H3>
  <A NAME="Hints">Hints</A>
</H3>
<P>
At small pixel sizes, the process of drawing the interior of an outline font
is quite difficult to do well. PostScript and TrueType have different approaches
to the problem of providing extra information to the rasterizer about how
to draw small fonts.
<TABLE BORDER CELLPADDING="2" ALIGN="Center">
  <CAPTION>
    <SMALL>Rasterization improvements<BR>
    from hinting TrueType.<BR>
    18pt font rasterized by Windows<BR>
    (scaled by a factor of 2)</SMALL>
  </CAPTION>
  <TR>
    <TD><P ALIGN=Center>
	&nbsp;&nbsp;<IMG SRC="HI.nohints.png" WIDTH="44" HEIGHT="28">&nbsp;&nbsp;<BR>
	no hints</TD>
    <TD><P ALIGN=Center>
	&nbsp;&nbsp;<IMG SRC="HI.hints.png" WIDTH="44" HEIGHT="28">&nbsp;&nbsp;<BR>
	hints</TD>
  </TR>
</TABLE>
<DL>
  <DT>
    <H4>
	PostScript
    </H4>
  <DD>
    Adobe incorporated several different ways of providing hints for the rasterizer
    about how things should be treated. The most obvious of these are the horizontal
    and vertical stem hints. Each glyph has its own set of hints to tell the
    rasterizer where to find stems. FontForge can usually figure out a reasonable
    set of stem hints (a process called
    <A HREF="hintsmenu.html#AutoHint">autohinting</A>), but some glyphs are too
    complex for it and it can make bad choices. It also provides a mode for you
    to override its choices.
    <P>
    Adobe also has a mechanism for handling dished serifs called flex hinting.
    This means a curve that is only slightly deformed from the horizontal (or
    vertical) will display as a line at small point sizes and as a curve at larger
    ones. FontForge will use these when it seems appropriate.
    <P>
    The original version of hints did not allow them to overlap, this meant that
    most serifs could not be described, Adobe then developed a mechanism called
    hint substitution which allows for different sets of non-overlapping hints
    to exist in different parts of the glyph. There are still shapes which cannot
    be fully hinted, but hint substitution is an improvement. The
    Hints-&gt;AutoHint command will figure out what stems overlap and where to
    change the current set of hints. The Hints-&gt;Hint Substitution Pts command
    will also figure where hint changes should occur, and the Hint Mask pane
    of the Point Info dialog gives the user direct control over this.
    <P>
    Most recently Adobe has provide a means to control the counters, the spaces
    between stems, in a glyph. The original Type1 description provided support
    for the horizontal counters in "m" and the vertical counters in "E" but more
    complex shapes could not be dealt with. Counter Hints (in a type1 font) may
    only be used with non-latin (non-greek, non-cyrillic) glyph sets, in type2
    (OpenType) things are a bit more complicated,. FontForge will generate counter
    hints when appropriate.
    <P>
    Adobe provides some font-wide hinting mechanisms. The two most obvious are
    the BlueValues and StemSnap settings in the
    <A HREF="fontinfo.html#Private">private dictionary</A>. BlueValues provides
    a list of vertical zones in which interesting things happen (so in a latin
    font this might include the ascender height, the cap-height, the x-height,
    the baseline and the descender height. At small point sizes everything within
    one of these zones will snap to the same height, while at larger point sizes
    the heights will be slightly different (for instance an "o" and an "x" usually
    have slightly different heights, but displaying that at a small point size
    would be ugly). Similarly the StemSnap variables specify standard stem widths
    for the font. FontForge will try to guess reasonable values for these. It
    also allows you to override these guesses and
    <A HREF="fontinfo.html#Private">specify your own values</A>. For a more
    comprehensible description of the private dictionary and what it can do,
    look at
    <A HREF="http://partners.adobe.com/asn/developer/PDFS/TN/T1_SPEC.PDF">Adobe's
    Type1 font specification</A>.<BR>
    <A NAME="HintOrder">FontForge</A>'s
    <A HREF="hintsmenu.html#AutoHint">AutoHint</A> command will work better if
    the BlueValues have been set. So before running AutoHint go to
    <A HREF="fontinfo.html#Private">Element-&gt; FontInfo-&gt; Private</A> to
    set this array. After AutoHinting you should regenerate the StemSnaps (also
    at Element-&gt; FontInfo-&gt; Private).
  <DT>
    <H4>
	<A NAME="TrueType">True</A> Type
    </H4>
  <DD>
    <TABLE ALIGN=Right>
	<TR>
	  <TD ALIGN=Center><IMG SRC="GridFitM.png" WIDTH="246" HEIGHT="241"><BR>
	    Grid Fit M</TD>
	</TR>
    </TABLE>
    <P>
    On the other hand, True Type says that figuring out what pixels to turn on
    would be a lot simpler if only the points and the splines were in the right
    place (ie. at pixel boundaries). And so True Type provides a set of instructions
    that move points around until they are positioned appropriately for a given
    size.
    <P>
    FontForge's hinting of True Type (properly called "instructing") is based
    on the stem hints also used by PostScript and on diagonal hints. It uses
    these hints to determine which points to move and where to move them.
    <P>
    When FontForge reads in a TrueType font it will store the instructions used,
    and when it next generates that font it will use those instructions -- provided
    no significant change has happened to a glyph.
</DL>
<P>
Most of my <A HREF="hinting.html">hinting user interface</A> is designed
with PostScript fonts in mind.
<H4>
  <A NAME="Type3">Type3 Fonts</A>
</H4>
<P>
Most people aren't interested in editing <A HREF="multilayer.html">Type3
PostScript fonts </A>(nor the equivalent SVG font), but if you want to, FontForge
can. Here
each layer represents a different drawing operation, and may specify a different
color, stroke, fill, etc. Layers are not font-wide, each glyph has its own
set of layers (which are not named). You can
<A HREF="multilayer.html#Layer">create new layers with a popup menu </A>in
the layers pane of the outline view.
<H4>
  Guidelines
</H4>
<P>
In FontForge guidelines live in their own mini-layer (it isn't a full layer
because all glyphs share the same set of guidelines rather than having an
individual layer for each glyph). It can be edited just like any other layer
and you may have guidelines of any shape you desire. You may also drag out
horizontal and vertical guidelines from the edges of the outline glyph view.
<H3>
  <A NAME="Scripts">Scripts</A>
</H3>
<P>
A script is a collection of letter shapes and rules for putting letters together.
For instance the latin script consists of the letters A-Z, written left to
right, along with a transformation from upper to lower case, a few ligatures
and rules for generating accents. Arabic is a script consisting of its own
character set, written right to left, along with transformations for initial,
medial, final and isolated forms, many ligatures and rules for placing vowel
marks.
<H3>
  <A NAME="Glyph-names">Glyph names &amp; Namelists</A>
</H3>
<P>
Within fontforge every glyph will have a name. Generally the glyph name will
be something that provides information about what the glyph looks like so
the name for the glyph representing "9" is "nine". Adobe has established
a
<A HREF="http://partners.adobe.com/public/developer/en/opentype/aglfn13.txt">standard
for what names may be assigned to what glyphs</A>, and when producing a font
for general use it is best to stick to that standard (Acrobat uses the glyph
names and recognizes the standard ones. If you try and use "neuf" for "nine"
Acrobat will not recognize it and surprising things will fail).
<P>
Adobe's standard provides reasonably mnemonic names for most latin and greek
glyphs (to English speakers anyway), some rather incomprehensible names for
cyrillic and hebrew (afiiXXXXX) and identifies most other glyphs by unicode
code point (uniXXXX or uXXXXX where "X" represents a hex digit and XXXX is
the unicode code point in hex).
<P>
If you are an english speaker and you are working with latin glyphs this
is fine and dandy. But if you are French you might wish that "adieresis"
were named "atréma" -- for that matter even if you are an English
speaker you might prefer it to be named "aumlaut". No matter who you are
you might prefer more mnemonic names for the code block you are working on.
<P>
FontForge has a concept called a
<A HREF="encodingmenu.html#namelist">namelist</A>, each of which is simply
a mapping from unicode code point to name. Several namelists may be defined,
different lists may apply to different fonts and a font may have all its
glyphs renamed from one namelist to another.
<P>
Namelists can also help navigating in a font. Even if a list does not apply
to a given font its names may be used in the goto dialog to find glyphs.
So if you've loaded a french namelist you can search for "atréma"
and FontForge will show you the glyph "adieresis" or "uni00E4" or "aumlaut"
or whatever.
<P>
A few caveats: Adobe's glyph name standard expects all glyph names to be
in ASCII characters. Syntactically postscript permits a wider range of glyph
names, but if you use non-ASCII characters some rasterizers might have problems.
Best to keep non-ASCII names within fontforge (and rename glyphs to adobe's
standard names before generating a font).
<H3>
  <A NAME="Lookups">Lookups,</A> Features, Scripts and Languages
</H3>
<P>
OpenType (and Apple Advanced Typography) allow various transformations to
be applied to the input glyph stream to produce an output glyph stream. These
transformations might include forming ligatures, kerning glyphs closer to
each other, attaching vowel marks or diacritics to letters, conditionally
replacing one glyph with another depending on the glyphs around it, etc.
<P>
The commands for each transformation are stored in what are called lookups.
If you were designing a set of lookups to handle latin ligatures, you might
have one lookup for ff, fl and ffl -- ligatures that happen almost all the
time, another for fi and ffi -- ligatures which don't happen in Turkish but
do in other languages, and lookups for ct and st -- ligatures which rarely
happen in English but are more frequent in German (I think).
<P>
A Feature is a tagged collection of lookups. The tags are all 4 letter sequences
(like 'liga') with standardized meanings. The 'liga' tag means standard
ligatures. The 'dlig' tag means discretionary ligatures, and 'kern' means
kerning. There are many others.
<P>
Every script (latin, cyrillic, han ideographs, ...) will have its own set
of features that are meaningful to it. Sometimes things will be even more
complicated, and each language within a script will have it's own set of
features. In the example above we might assign scripts, languages, features
and lookups thusly:
<TABLE BORDER CELLPADDING="2">
  <TR>
    <TH>Script</TH>
    <TH>Language</TH>
    <TH>Feature</TH>
    <TH>Lookups</TH>
    <TH>Comments</TH>
  </TR>
  <TR>
    <TD ROWSPAN=7>latn</TD>
    <TD ROWSPAN=3>default</TD>
    <TD ROWSPAN=2>liga (standard)</TD>
    <TD>lookup for ff, fl and ffl</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>lookup for fi and ffi</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>dlig (discretionary)</TD>
    <TD>lookup for ct and st</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>Turkish</TD>
    <TD>liga</TD>
    <TD>lookup for ff, fl and ffl</TD>
    <TD>Lookups may be shared, so this can be the same lookup as above<BR>
	(Turkish distinguishes between i and dotlessi and fi ligatures hide this
	distinction.)</TD>
  </TR>
  <TR>
    <TD ROWSPAN=3>German</TD>
    <TD ROWSPAN=3>liga</TD>
    <TD>lookup for ff, fl and ffl</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>lookup for fi and ffi</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>lookup for ct and st</TD>
    <TD>Lookups may even be shared by a different feature type, so for English
	and Spanish ct might count as a discretionary ligature, one rarely used,
	while in German it mght be more common and be part of the standard ligature
	set.</TD>
  </TR>
</TABLE>
<P>
The default language means any language in the script which is not specifically
named. So in the above example the default language would be any language
except Turkish and German that might use the latin script.
<P>
It is also possible to have a default script. The digits 0-9, are used in
many writing systems, not just latin and are considered Common to most scripts.
If you have lookups which apply to the digits (conversion to oldstyle digits,
or to proportional digits, or to superscripts...) you should attach those
lookups to features in all scripts (and languages) that could use them, and
to the default script (just in case).
<TABLE BORDER CELLPADDING="2">
  <TR>
    <TH>Script</TH>
    <TH>Language</TH>
    <TH>Feature</TH>
    <TH>Lookups</TH>
    <TH>Comments</TH>
  </TR>
  <TR>
    <TD ROWSPAN=9>latn</TD>
    <TD ROWSPAN=3>default</TD>
    <TD>pnum</TD>
    <TD>proportional number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>onum</TD>
    <TD>old style number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>subs</TD>
    <TD>subscript lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD ROWSPAN=3>Turkish</TD>
    <TD>pnum</TD>
    <TD>proportional number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>onum</TD>
    <TD>old style number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>subs</TD>
    <TD>subscript lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD ROWSPAN=3>German</TD>
    <TD>pnum</TD>
    <TD>proportional number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>onum</TD>
    <TD>old style number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>subs</TD>
    <TD>subscript lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD ROWSPAN=3>cyrl</TD>
    <TD ROWSPAN=3>default</TD>
    <TD>pnum</TD>
    <TD>proportional number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>onum</TD>
    <TD>old style number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>subs</TD>
    <TD>subscript lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD ROWSPAN=3>DFLT</TD>
    <TD ROWSPAN=3>default</TD>
    <TD>pnum</TD>
    <TD>proportional number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>onum</TD>
    <TD>old style number lookup</TD>
    <TD></TD>
  </TR>
  <TR>
    <TD>subs</TD>
    <TD>subscript lookup</TD>
    <TD></TD>
  </TR>
</TABLE>
<P>
There are roughly 15 different types of lookups which contain different
information. Different kinds of lookup are needed to specify ligature data,
glyph substitution data and kerning data.
<P>
Lookups may be specified with the
<A HREF="fontinfo.html#Lookups">Element-&gt;Font Info</A> dialog
<H4>
  Lookup subtables
</H4>
<P>
I talk above about lookups as if they were simple things. Unfortunately they
aren't. Each lookup is composed of "Subtables" which actually do the work.
<P>
A lookup may contain several subtables. Most contain exactly one. (If a lookup
contains no subtables it will do nothing).
<P>
I said there were about 15 kinds of lookup, there are even more kinds of
subtable. For instance a subtable which specifies glyph to glyph kerning
is different from one which specifies glyph class to glyph class kerning.
<P>
At first glance the subtable may seem an unnecessary complication, but it
turns out to be desirable for one lookup to contain several kinds of sub-table
data. For instance, a kerning lookup might include one subtable providing
glyph class kerning, and then another subtable providing exceptions to that
on a glyph by glyph basis.
<H4>
  How lookups are applied
</H4>
<P>
When a word processor deals with text, it will figure out what script is
in use in the text. Somehow it will figure out what the language is (maybe
it will just assume the "DFLT" language, maybe the user told it the text
was in French, maybe the locale is Spanish, ...).
<P>
In any script/language some features are applied by default, while others
may be applied at the user's discression. So in English the "liga" feature
should always be applied, while the "dlig" feature should only be applied
if the user asked for it. (Not all programs follow this at the moment, but
that's the theory).
<P>
The word processor will build up a list of features that might be active.
Then it looks in the font and sees which of those features are available
for this script and language. In turn each feature is composed of lookups,
and all lookups in all active features will be marked as active.
<P>
Lookups will be executed in the order in which they occur in the lookup list
(which is also the order shown in the Font Info-&gt;Lookup pane, but may
be quite different from the order in which the features were listed). And
all active lookups will be executed.
<P>
This ordering can be important. If you have both a small-caps lookup and
a ligature lookup active, and the text is "fi" then the order of the lookups
will probably matter. If the small-caps lookup happens first then the "fi"
will become "<SMALL>FI</SMALL>" and the ligature feature will not be applied.
If the ligature happens first then you will see an "fi" ligature for which
there is probably no small-caps glyph. In one case you get small-caps, in
another a ligature. Probably, here, you would like the small-caps lookup
to happen first.
<P>
Lookup subtables make life even more interesting. When a lookup is executed
the subtables within that lookup are activated in turn <EM>until one
succeeds</EM>. After that no further subtables will be applied.
<P>
So in the kerning example mentioned above, you would want to put the special
case glyph to glyph subtable first, and then the glyph class to class subtable
second. When a special case combination occurs the first subtable will succeed
(and kern the combination) and the class subtable will not be used. For
combinations which aren't special cases, then the first subtable will fail,
and the second will be applied.
<H4>
  GPOS and GSUB
</H4>
<P>
Up till now I have spoken as there were one list of lookups. That was a
simplification. There are two broad classes of lookup, and two lists. There
are those involved in manipulating the glyphs themselves (glyph substitution,
ligation, decomposition, etc.) and those involved in positioning glyphs relative
to others (kerning, mark attachment, etc.).
<P>
The GSUB table contains all the glyph substitution lookups and <EM>all</EM>
of them will be processed before any positioning lookups are attempted.
<P>
The GPOS table contains all the glyph positioning lookups.
<H3>
  <A NAME="Anchors">Anchor Points and Classes</A>
</H3>
<P>
Anchor points allow fine control of the positioning of two (or several) glyphs.
There are several different styles of attachment based on anchors: cursive,
mark to base, mark to ligature and mark to mark positioning. The first style
is used to join glyphs in flowing scripts (cursive) where the exit from one
glyph joins the entry point of the next. In the second style one of the glyphs
is the base glyph, and it will be positioned normally, the other glyph which
will often be a diacritic or vowel mark will be positioned so that the anchor
points in each glyph are coincident. Mark to ligature behaves similarly to
mark to base except that there may be more that one attachment point on the
ligature depending on which component a given mark is connected to. Finally,
mark to mark allows you to position two marks with respect to each other
(as you might need to do in vietnamese or hebrew where you may get several
marks for one glyph).
<P>
That is badly said. Consider the following two glyphs and how they are joined
to make the final result:
<TABLE>
  <TR>
    <TD><IMG SRC="a_with_anchor.png" WIDTH=104 HEIGHT=208></TD>
    <TD>+</TD>
    <TD><IMG SRC="grave_with_anchor.png" WIDTH=66 HEIGHT=208></TD>
    <TD>=&gt;</TD>
    <TD><IMG SRC="agrave_anchored.png" WIDTH=104 HEIGHT=208></TD>
  </TR>
</TABLE>
<P>
The grave accent has been raised and moved to the right so that its anchor
point is positioned where the anchor from "a" was.
<P>
FontForge does not compose these glyphs (well, it can, but that's a completely
different area), instead it provides information within the
<A HREF="gposgsub.html">font</A> to a text layout program so that the program
can do the composition.
<P>
The example above is unlikely to be very useful since most latin fonts contain
pre-composed a-grave glyphs, but the same concepts apply to arabic and hebrew
where the number of variants is larger and the precomposed glyphs fewer.
<P>
That's roughly how anchor points are used. Now the mechanics.
<P>
Each of the different attachment styles mentioned above (cursive, mark to
base, mark to ligature and mark to mark) is a different type of GPOS lookup.
If you want to do attachment positioning you must first create the appropriate
lookup (<A HREF="fontinfo.html#Lookups">Element-&gt;Font
Info-&gt;Lookups-&gt;GPOS</A>, then a lookup subtable, and then an anchor
class within the lookup subtable. An anchor class is specified by providing
a name for it (in the above example the class was called "Top").
<P>
Cursive attachments are a little different from the other attachment types.
Each glyph has two attachment points, an entry and an exit (instead of just
the one shown in the mark to base example above). The text layout program
will attach the exit point of one glyph to the entry point of the next.
<P>
A glyph may contain several Anchor Points, but only one for each mark to
base anchor class (ligatures may have more than one for a class, and 'curs'
and 'mkmk' classes will usually have two). Inside a glyph may create a point
with the <A HREF="pointmenu.html#AddAnchor">Point-&gt;Add Anchor command</A>.
You must specify an anchor class, and whether this point is in a base glyph
or in a mark glyph, and a location. So in the example above the anchor point
in "a" has class "Top" and is a base glyph, while the anchor point in "grave"
also has class "Top" but is a mark glyph. There may be many base glyphs with
an anchor point named "Top" and many mark glyphs also with "Top" anchor points.
Any base glyph with a "Top" anchor point maybe composed with any mark glyph
with a "Top" anchor point. So instead of specifying the exact composed form
for all possible combinations we specify far fewer anchor points for the
same effect.
<P>
But life is not really that simple. Ligatures may need several anchor points
of the same class (one above each component for example). When you create
your anchor point you may say that it is to be in a ligature, in which case
you will also be asked for a ligature index -- a number running from 0 to
the number of components in the ligature -1. This allows you to position
several anchor points with the same class. The text layout program will place
the first mark over the first anchor point, the second mark over the second
and so on (this is a gross simplification).
<P>
Finally you may need to position two marks based on the same anchor point,
for example the glyph <IMG SRC="a_dieresis_macron.png" WIDTH=9 HEIGHT=14>
has a diaeresis and a macron over it. Both of which might normally be positioned
with the Top anchor class. Instead we define a special class for positioning
one mark with respect to another. When creating the anchor class specify
a tag of 'mkmk' (mark to mark) and call it something like "TopMark". When
you create a new anchor point for diaeresis you specify that it is a <EM>base
mark</EM> and you position it above the glyph, while the new anchor point
in macron should be of type mark and should be positioned at the same place
as the "Top" anchor point. Thus when given the sequence of glyphs "a diaeresis
macron" the text layout program should position "a" normally, position
"diaeresis" so that the its Top anchor point is where "a"'s is, and position
macron so that its TopMark anchor point is where "diaeresis"'s is.
<P>
Anchor points may be selected, dragged, transformed, cut, copied and pasted.
<H3>
  <A NAME="Baseline">Baseline</A>s
</H3>
<P>
To a user of the latin alphabet it makes sense for the vertical origin of
a glyph to be the baseline on which most letters
rest<IMG SRC="latinBaseline.png" WIDTH="93" HEIGHT="45">. This means that
if you change the pointsize of a glyph it will still line up
properly<IMG SRC="latinNormalBaseline.png" WIDTH="91" HEIGHT="21">. This
is so obvious we don't even think about it. But if you put the vertical origin
at the top of the letter then the letters will be aligned quite differently,
and to our eyes,
unexpectedly<IMG SRC="latinHangBaseline.png" WIDTH="90" HEIGHT="21">.
<P>
Different scripts have different expectations of how glyphs should be aligned.
In latin (cyrillic, greek, arabic, hebrew, etc.) the alignment point, the
baseline, is somewhere in the middle of the possible extent of a glyph --
that is the script has both ascenders above the baseline and descenders below
it.
<P>
But not all scripts are like that. In Devanagari the alignment point is near
the top of the glyph -- indeed most glyphs will draw in the baseline
explicitly<IMG SRC="devaBaseline.png" WIDTH="97" HEIGHT="46">. If you change
the pointsize you want glyphs to line up on this
line<IMG SRC="devaHangBaseline.png" WIDTH="82" HEIGHT="21">, and not down
at the bottom of the glyph
<IMG SRC="devalatinBaseline.png" WIDTH="76" HEIGHT="18">.
<P>
In CJK ideographs the baseline is usually drawn at the bottom edge of the
square which contains the glyph.
<P>
However if you try and typeset these different scripts together with their
baselines in the same place you get a mess:
<IMG SRC="misalignedBaselines.png" WIDTH="65" HEIGHT="38">. It would be much
nicer if it were possible to say that these different scripts have their
baselines in different places so that the glyphs can fit together
reasonably:<IMG SRC="alignedBaselines.png" WIDTH="65" HEIGHT="23">. Both
Apple Typography and OpenType allow for this. There is a
<A HREF="baseline.html">baseline table </A>which says how the baselines for
each script (or each glyph) should be aligned with respect to other baselines.

<P ALIGN=Center>
-- <A HREF="editexample.html">Next</A> --
</BODY></HTML>
